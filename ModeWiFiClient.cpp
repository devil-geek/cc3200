#include "WiFi.h"
#include "SimpleLog.h"
#include "ModeWiFiClient.h"

#define ROOTCA_CERT_FILE "/cert/digi.cert"

const static unsigned char rootCACertByteArray[] = {
0x30, 0x82, 0x3, 0xaf, 0x30, 0x82, 0x2, 0x97, 0xa0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x10, 0x8, 
0x3b, 0xe0, 0x56, 0x90, 0x42, 0x46, 0xb1, 0xa1, 0x75, 0x6a, 0xc9, 0x59, 0x91, 0xc7, 0x4a, 0x30, 
0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x5, 0x5, 0x0, 0x30, 0x61, 
0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x15, 0x30, 
0x13, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0xc, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 
0x20, 0x49, 0x6e, 0x63, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xb, 0x13, 0x10, 0x77, 
0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 
0x20, 0x30, 0x1e, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x17, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 
0x72, 0x74, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 
0x41, 0x30, 0x1e, 0x17, 0xd, 0x30, 0x36, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x5a, 0x17, 0xd, 0x33, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x5a, 0x30, 0x61, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 
0x31, 0x15, 0x30, 0x13, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0xc, 0x44, 0x69, 0x67, 0x69, 0x43, 
0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0xb, 
0x13, 0x10, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 
0x6f, 0x6d, 0x31, 0x20, 0x30, 0x1e, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x17, 0x44, 0x69, 0x67, 
0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f, 
0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x1, 0x22, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 
0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3, 0x82, 0x1, 0xf, 0x0, 0x30, 0x82, 0x1, 0xa, 
0x2, 0x82, 0x1, 0x1, 0x0, 0xe2, 0x3b, 0xe1, 0x11, 0x72, 0xde, 0xa8, 0xa4, 0xd3, 0xa3, 0x57, 
0xaa, 0x50, 0xa2, 0x8f, 0xb, 0x77, 0x90, 0xc9, 0xa2, 0xa5, 0xee, 0x12, 0xce, 0x96, 0x5b, 0x1, 
0x9, 0x20, 0xcc, 0x1, 0x93, 0xa7, 0x4e, 0x30, 0xb7, 0x53, 0xf7, 0x43, 0xc4, 0x69, 0x0, 0x57, 
0x9d, 0xe2, 0x8d, 0x22, 0xdd, 0x87, 0x6, 0x40, 0x0, 0x81, 0x9, 0xce, 0xce, 0x1b, 0x83, 0xbf, 
0xdf, 0xcd, 0x3b, 0x71, 0x46, 0xe2, 0xd6, 0x66, 0xc7, 0x5, 0xb3, 0x76, 0x27, 0x16, 0x8f, 0x7b, 
0x9e, 0x1e, 0x95, 0x7d, 0xee, 0xb7, 0x48, 0xa3, 0x8, 0xda, 0xd6, 0xaf, 0x7a, 0xc, 0x39, 0x6, 
0x65, 0x7f, 0x4a, 0x5d, 0x1f, 0xbc, 0x17, 0xf8, 0xab, 0xbe, 0xee, 0x28, 0xd7, 0x74, 0x7f, 0x7a, 
0x78, 0x99, 0x59, 0x85, 0x68, 0x6e, 0x5c, 0x23, 0x32, 0x4b, 0xbf, 0x4e, 0xc0, 0xe8, 0x5a, 0x6d, 
0xe3, 0x70, 0xbf, 0x77, 0x10, 0xbf, 0xfc, 0x1, 0xf6, 0x85, 0xd9, 0xa8, 0x44, 0x10, 0x58, 0x32, 
0xa9, 0x75, 0x18, 0xd5, 0xd1, 0xa2, 0xbe, 0x47, 0xe2, 0x27, 0x6a, 0xf4, 0x9a, 0x33, 0xf8, 0x49, 
0x8, 0x60, 0x8b, 0xd4, 0x5f, 0xb4, 0x3a, 0x84, 0xbf, 0xa1, 0xaa, 0x4a, 0x4c, 0x7d, 0x3e, 0xcf, 
0x4f, 0x5f, 0x6c, 0x76, 0x5e, 0xa0, 0x4b, 0x37, 0x91, 0x9e, 0xdc, 0x22, 0xe6, 0x6d, 0xce, 0x14, 
0x1a, 0x8e, 0x6a, 0xcb, 0xfe, 0xcd, 0xb3, 0x14, 0x64, 0x17, 0xc7, 0x5b, 0x29, 0x9e, 0x32, 0xbf, 
0xf2, 0xee, 0xfa, 0xd3, 0xb, 0x42, 0xd4, 0xab, 0xb7, 0x41, 0x32, 0xda, 0xc, 0xd4, 0xef, 0xf8, 
0x81, 0xd5, 0xbb, 0x8d, 0x58, 0x3f, 0xb5, 0x1b, 0xe8, 0x49, 0x28, 0xa2, 0x70, 0xda, 0x31, 0x4, 
0xdd, 0xf7, 0xb2, 0x16, 0xf2, 0x4c, 0xa, 0x4e, 0x7, 0xa8, 0xed, 0x4a, 0x3d, 0x5e, 0xb5, 0x7f, 
0xa3, 0x90, 0xc3, 0xaf, 0x27, 0x2, 0x3, 0x1, 0x0, 0x1, 0xa3, 0x63, 0x30, 0x61, 0x30, 0xe, 
0x6, 0x3, 0x55, 0x1d, 0xf, 0x1, 0x1, 0xff, 0x4, 0x4, 0x3, 0x2, 0x1, 0x86, 0x30, 0xf, 
0x6, 0x3, 0x55, 0x1d, 0x13, 0x1, 0x1, 0xff, 0x4, 0x5, 0x30, 0x3, 0x1, 0x1, 0xff, 0x30, 
0x1d, 0x6, 0x3, 0x55, 0x1d, 0xe, 0x4, 0x16, 0x4, 0x14, 0x3, 0xde, 0x50, 0x35, 0x56, 0xd1, 
0x4c, 0xbb, 0x66, 0xf0, 0xa3, 0xe2, 0x1b, 0x1b, 0xc3, 0x97, 0xb2, 0x3d, 0xd1, 0x55, 0x30, 0x1f, 
0x6, 0x3, 0x55, 0x1d, 0x23, 0x4, 0x18, 0x30, 0x16, 0x80, 0x14, 0x3, 0xde, 0x50, 0x35, 0x56, 
0xd1, 0x4c, 0xbb, 0x66, 0xf0, 0xa3, 0xe2, 0x1b, 0x1b, 0xc3, 0x97, 0xb2, 0x3d, 0xd1, 0x55, 0x30, 
0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x5, 0x5, 0x0, 0x3, 0x82, 
0x1, 0x1, 0x0, 0xcb, 0x9c, 0x37, 0xaa, 0x48, 0x13, 0x12, 0xa, 0xfa, 0xdd, 0x44, 0x9c, 0x4f, 
0x52, 0xb0, 0xf4, 0xdf, 0xae, 0x4, 0xf5, 0x79, 0x79, 0x8, 0xa3, 0x24, 0x18, 0xfc, 0x4b, 0x2b, 
0x84, 0xc0, 0x2d, 0xb9, 0xd5, 0xc7, 0xfe, 0xf4, 0xc1, 0x1f, 0x58, 0xcb, 0xb8, 0x6d, 0x9c, 0x7a, 
0x74, 0xe7, 0x98, 0x29, 0xab, 0x11, 0xb5, 0xe3, 0x70, 0xa0, 0xa1, 0xcd, 0x4c, 0x88, 0x99, 0x93, 
0x8c, 0x91, 0x70, 0xe2, 0xab, 0xf, 0x1c, 0xbe, 0x93, 0xa9, 0xff, 0x63, 0xd5, 0xe4, 0x7, 0x60, 
0xd3, 0xa3, 0xbf, 0x9d, 0x5b, 0x9, 0xf1, 0xd5, 0x8e, 0xe3, 0x53, 0xf4, 0x8e, 0x63, 0xfa, 0x3f, 
0xa7, 0xdb, 0xb4, 0x66, 0xdf, 0x62, 0x66, 0xd6, 0xd1, 0x6e, 0x41, 0x8d, 0xf2, 0x2d, 0xb5, 0xea, 
0x77, 0x4a, 0x9f, 0x9d, 0x58, 0xe2, 0x2b, 0x59, 0xc0, 0x40, 0x23, 0xed, 0x2d, 0x28, 0x82, 0x45, 
0x3e, 0x79, 0x54, 0x92, 0x26, 0x98, 0xe0, 0x80, 0x48, 0xa8, 0x37, 0xef, 0xf0, 0xd6, 0x79, 0x60, 
0x16, 0xde, 0xac, 0xe8, 0xe, 0xcd, 0x6e, 0xac, 0x44, 0x17, 0x38, 0x2f, 0x49, 0xda, 0xe1, 0x45, 
0x3e, 0x2a, 0xb9, 0x36, 0x53, 0xcf, 0x3a, 0x50, 0x6, 0xf7, 0x2e, 0xe8, 0xc4, 0x57, 0x49, 0x6c, 
0x61, 0x21, 0x18, 0xd5, 0x4, 0xad, 0x78, 0x3c, 0x2c, 0x3a, 0x80, 0x6b, 0xa7, 0xeb, 0xaf, 0x15, 
0x14, 0xe9, 0xd8, 0x89, 0xc1, 0xb9, 0x38, 0x6c, 0xe2, 0x91, 0x6c, 0x8a, 0xff, 0x64, 0xb9, 0x77, 
0x25, 0x57, 0x30, 0xc0, 0x1b, 0x24, 0xa3, 0xe1, 0xdc, 0xe9, 0xdf, 0x47, 0x7c, 0xb5, 0xb4, 0x24, 
0x8, 0x5, 0x30, 0xec, 0x2d, 0xbd, 0xb, 0xbf, 0x45, 0xbf, 0x50, 0xb9, 0xa9, 0xf3, 0xeb, 0x98, 
0x1, 0x12, 0xad, 0xc8, 0x88, 0xc6, 0x98, 0x34, 0x5f, 0x8d, 0xa, 0x3c, 0xc6, 0xe9, 0xd5, 0x95, 
0x95, 0x6d, 0xde
};

const static int rootCACertByteArrayLength = sizeof(rootCACertByteArray);

int ModeWiFiClient::setDeviceTime(int year, int mon, int day, int hour, int min, int sec) {
  typedef struct {
    /* time */
    unsigned long tm_sec;
    unsigned long tm_min;
    unsigned long tm_hour;
    /* date */
    unsigned long tm_day;
    unsigned long tm_mon;
    unsigned long tm_year;
    unsigned long tm_week_day; //not required
    unsigned long tm_year_day; //not required
    unsigned long reserved[3];
  } SlDateTime;

  SlDateTime dateTime;

  dateTime.tm_day = day;
  dateTime.tm_mon = mon;
  dateTime.tm_year = year;
  dateTime.tm_sec = sec;
  dateTime.tm_hour = hour;
  dateTime.tm_min = min;

  return sl_DevSet(SL_DEVICE_GENERAL_CONFIGURATION, SL_DEVICE_GENERAL_CONFIGURATION_DATE_TIME,
      sizeof(SlDateTime),(unsigned char *)(&dateTime));
}

int printError(const char* msg, int err) {
  ERROR_LOG(msg);
  ERROR_LOGN(String(err, 10).c_str());
  return err;
}

bool certIsDifferent(const unsigned char *buf, int size) {
  if (size != rootCACertByteArrayLength) {
    return true;
  }

  for (int i = 0; i < size; ++i) {
    if (buf[i] != rootCACertByteArray[i]) {
      return true;
    }
  }

  return false;
}

int createCertFile() {
  DEBUG_LOGN("Creating certificate file");

  long certificateFile = -1;
  int err = sl_FsOpen((unsigned char *)ROOTCA_CERT_FILE,
      FS_MODE_OPEN_CREATE(2048, _FS_FILE_OPEN_FLAG_COMMIT | _FS_FILE_PUBLIC_WRITE),
      NULL, &certificateFile);
  sl_FsClose(certificateFile, 0, 0, 0);

  if (err < 0) {
    return printError("Error not enough block for cert file: ", err);
  }

  certificateFile = -1;

  err = sl_FsOpen((unsigned char *)ROOTCA_CERT_FILE, FS_MODE_OPEN_WRITE, NULL, &certificateFile);
  if (err < 0) {
    sl_FsClose(certificateFile, 0, 0, 0);
    return printError("Error opening certificate file: ", err);
  }

  err = sl_FsWrite(certificateFile, 0, (unsigned char*)rootCACertByteArray, rootCACertByteArrayLength);
  if (err < 0) {
    sl_FsClose(certificateFile, 0, 0, 0);
    return printError("Error wrting certificate file: ", err);
  }
  DEBUG_LOGN("Written cert file.\r\n");

  sl_FsClose(certificateFile, 0, 0, 0);

  return 0;
}

int checkCertFileAndDelete(bool* certDeleted, long certificateFile) {
  DEBUG_LOG("SSL cert file is found: ");
  DEBUG_LOGN(ROOTCA_CERT_FILE);

  SlFsFileInfo_t fsFileInfo;

  int err = sl_FsGetInfo((unsigned char *)ROOTCA_CERT_FILE, NULL, &fsFileInfo);

  if (err < 0) {
    return printError("Failed to get cert file info: ", err);
  }

  const int size = fsFileInfo.FileLen;
  unsigned char* buf = (unsigned char*)malloc(size);
  err = sl_FsRead(certificateFile, 0,  buf, size);
  if(err < 0) {
    sl_FsClose(certificateFile, 0, 0, 0);
    free(buf);
    return printError("Failed to read cert file: ", err);
  }

  if (certIsDifferent(buf, size)) {
    sl_FsClose(certificateFile, 0, 0, 0);
    DEBUG_LOGN("Delete certificate cert file.");
    err = sl_FsDel((unsigned char*)ROOTCA_CERT_FILE, 0);
    if (err < 0) {
      return printError("Failed to delete cert file: ", err);
    }
    *certDeleted = true;
  }
  return 0;
}

int checkAndCreateRootCACertReal() {
  // This function is called only once when first SSL connection happens.
  long certificateFile = -1;

  bool certNotFound = false;
  bool certDeleted = false;
  int err = sl_FsOpen((unsigned char *)ROOTCA_CERT_FILE, FS_MODE_OPEN_READ, NULL, &certificateFile);

  if (err != 0) {
    DEBUG_LOG("SSL cert file is not found: ");
    DEBUG_LOGN(ROOTCA_CERT_FILE);
    certNotFound = true;
  } else {
    err = checkCertFileAndDelete(&certDeleted, certificateFile);
    if (err != 0) {
      return err;
    }
  }

  sl_FsClose(certificateFile, 0, 0, 0);

  if (certDeleted || certNotFound) {
    return createCertFile();
  }

  return 0;
}

bool ModeWiFiClient::m_ssl_checked = false;

bool ModeWiFiClient::checkAndCreateRootCACert() {
  if (!m_ssl_checked) {
    // Only checkAndCreateRootCACertReal is called once in the execution.
    int err = checkAndCreateRootCACertReal();
    if (err == 0) {
      m_ssl_checked = true;
    }
  }
  return m_ssl_checked;
}

int32_t ModeWiFiClient::sslGetReasonID()
{
  return sslLastError;
}

const char* ModeWiFiClient::sslGetReason()
{
  switch (sslLastError) {
    case SL_SOC_OK:
      return "OK";
    case SL_ESECSNOVERIFY:
      return "SL_ESECSNOVERIFY - SSL verification not enabled";
    case SL_ESECDATEERROR:
      return "SL_ESECDATEERROR - Connected, but RootCA date error";
    case SL_ESEC_ASN_SIG_CONFIRM_E:
      return "SL_ESEC_ASN_SIG_CONFIRM_E - RootCA could not verify site cert";
    case SL_ESECBADCAFILE:
      return "SL_ESECBADCAFILE - Bad RootCA file (needs DER binary format, not PEM)";
  }
  return "UNKNOWN";
}

int ModeWiFiClient::sslConnect(IPAddress ip, uint16_t port) {
  checkAndCreateRootCACert();

  hasRootCA = true;

  // Most of the code is the same as sslConnect() inside WiFiClient class.
  // But in order to use our own SSL cert and use strict verification requirements, we have to override the code.

  //
  //this function should be called only once and on the client side
  //
  if (_socketIndex != NO_SOCKET_AVAIL) {
    return false;
  }

  //
  //get a socket index and attempt to create a socket
  //note that the socket is intentionally left as BLOCKING. This allows an
  //abusive user to send as many requests as they want as fast as they can try
  //and it won't overload simplelink.
  //
  int socketIndex = WiFiClass::getSocket();
  if (socketIndex == NO_SOCKET_AVAIL) {
    return false;
  }

  int socketHandle = sl_Socket(SL_AF_INET, SL_SOCK_STREAM, SL_SEC_SOCKET);
  if (socketHandle < 0) {
    return false;
  }

  // Utilize rootCA file for verifying server certificate if it's been supplied with .sslRootCA() previously
  if (hasRootCA) {
    sl_SetSockOpt(socketHandle, SL_SOL_SOCKET, SL_SO_SECURE_FILES_CA_FILE_NAME, ROOTCA_CERT_FILE, strlen(ROOTCA_CERT_FILE));
  }
  sslIsVerified = true;

  //
  //connect the socket to the requested IP address and port. Check for success
  //

  SlSockAddrIn_t server = {0};
  server.sin_family = SL_AF_INET;
  server.sin_port = sl_Htons(port);
  server.sin_addr.s_addr = ip;
  int iRet = sl_Connect(socketHandle, (SlSockAddr_t*)&server, sizeof(SlSockAddrIn_t));

  if ( iRet < 0 && (iRet != SL_ESECSNOVERIFY && iRet != SL_ESECDATEERROR) ) {
    sslLastError = iRet;
    sl_Close(socketHandle);
    return false;
  }

  // Always need to check strick for SSL.
  sslVerifyStrict = true;

  // If the remote-end server cert could not be verified, and we demand strict verification, ABORT.
  if ( sslVerifyStrict && (iRet == SL_ESECSNOVERIFY || iRet == SL_ESECDATEERROR) ) {
    sslLastError = iRet;
    sl_Close(socketHandle);
    return false;
  }

  if (iRet == SL_ESECSNOVERIFY || iRet == SL_ESECDATEERROR) {
    sslLastError = iRet;
    sslIsVerified = false;
  }

  int enableOption = 1;
  sl_SetSockOpt(socketHandle, SL_SOL_SOCKET, SL_SO_NONBLOCKING, &enableOption, sizeof(enableOption));
  sl_SetSockOpt(socketHandle, SL_SOL_SOCKET, SL_SO_KEEPALIVE, &enableOption, sizeof(enableOption));

  //
  //we've successfully created a socket and connected, so store the
  //information in the arrays provided by WiFiClass
  //
  _socketIndex = socketIndex;
  WiFiClass::_handleArray[socketIndex] = socketHandle;
  WiFiClass::_typeArray[socketIndex] = TYPE_TCP_CLIENT;
  WiFiClass::_portArray[socketIndex] = port;
  return true;

}


